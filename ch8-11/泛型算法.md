# 概述
算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。这种执行于迭代器上但不会执行容器的操作特性使得算法永远不会改变底层容器的大小。它可能会改变容器中保存的元素，也可能在容器中移动元素，但不会直接在容器中添加或删除元素。

注意到标准库还实现了一类特殊的迭代器，称为插入器(inserter)。这类迭代器操作时会在底层的容器上执行插入操作。其实这只是迭代器可以完成向容器添加元素的效果，但算法本身永远不会这样的操作


划分算法的基本方法就是: 了解它们是否读取元素、改变元素或者重排元素顺序

# 定制算法中的操作
谓词操作，一个可调用的表达式，返回结果是一个能用作条件的值。
接受谓词参数的算法对输入序列中的元素调用谓，因此元素类型必须能转换为谓词的参数类型。按谓词接受的参数个数分为两类:　一元谓词和二元谓词。它可以代替sort算法中的`<`运算符来比较元素


可调用对象可以是函数和函数指针，还有另外两种:　重载了函数调用运算符的类及lambda表达式。它可以理解为一个未命名的内敛函数，并且定义在函数内部
，形式如下:
```
[capture-list](parameter-list) -> return type {
	
}
```

要求lambda必须使用尾置返回来指定返回类型(要么有return自动推断返回类型，要么返回void)。如果想传入其他参数，使用捕获列表，它可以用于lambda所在函数定义的局部变量列表中。

例如
完成isShorter函数相同功能的lambda:
```
bool isShorter(const string& s1,const string& s2) {
	return s1.size() < s2.size();
}

[](const string& s1,const string& s2) {
	return s1.size() < s2.size();
}
```

如果你想实现打印出给定长度大于某个值的单词，例如find_if的第三个参数只能接受一元谓词(输入序列中的元素当做参数)，至于想传递第二个参数表示长度，那是不可能的。lambda表达式解决这样的问题，具体的解释是

一个lambda通过将局部变量包含在其捕获列表中来之处将会使用这些变量。捕获列表会指引lambda在其内部包含访问局部变量所需的信息。

例如这个lambda会捕获sz,并且接受单一的string参数。函数体内会利用捕获值进行比较
```
[sz](const string& s) {
	return s.size() >= sz;
}
```

强调一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

捕获列表只用于局部的非static变量，而lambda可以直接使用局部static变量和它所在函数外的声明

