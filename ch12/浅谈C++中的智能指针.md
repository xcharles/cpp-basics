
# 前言
在C++中动态管理内存的操作是由一对运算符完成的: `new`运算符为对象分配内存并返回一个指向该对象的指针;`delete`运算符释放指针指向的对象内存，但是也很容易出现一些内存管理上的问题。和C中管理内存的`malloc`和`free`操作一样，使用不当它们都会出现一些内存错误问题。如下为一些典型的内存问题

* 内存泄露: 分配了内存，却忘记了销毁，对象的内存并未被释放

智能指针和普通指针的区别就在于智能指针实际上是依赖于RAII机制对指向对象的普通指针进行了一层封装，从而使得智能指针可以自动管理对象的生命期，无需手动释放，同时也要注意到运行时发生异常它仍能保证异常安全。因为一个对象什么时候和在什么条件下要被析构或者是删除是由智能指针内部机制决定的，用户并不需要关注。孟岩点评智能指针的优点:

> C++利用智能指针达成的效果是: 一旦某对象不再被引用，系统刻不容缓，立刻回收内存

另外陈硕还提到了智能指针的另外一个作用，将值语义转换为引用语义(对象语义)。它对于我们理解C++和Java的实质区别、认识引用计数的本质以及为什么不同语言对于字符串有不同的设计策略: C++中string类的写时复制策略、将Java中String类设计为不变类。
 

理解智能指针的引用计数原理，有助于理解一些语言的垃圾自动回收收集(GC)机制。本质上GC机制中的标记清除策略就是一张图在不停地进行深搜(执行有向可达性程序)，遍历所有可被访问到的对象，清除所有未被标记的对象回收内存。它能让我们更理解一些对性能要求比较高(延迟敏感)的领域如游戏、金融交易的核心模块等倾向于使用C++而不是Java。因为相比于垃圾收集带来的不确定延时，C++可以通过智能指针自动精确地管理对象的生命期。

似乎我们从学C++一开始时就被告知C++性能优于Java，而具体的原因，除了模糊地了解到C++可精确地管理对象生命期外，其他的解释就不知道了。另外一个原因就是C++中紧凑的对象模型，优化了内存访问的局部性(locality of reference),用图说话: 对比C++和Java的对象模型


由此联想到一点:在研究生阶段使用Ocaml这种函数式语言写过毕设，深深感受到了函数式语言在类型自动推断(代码一旦编写正确就很少需要调试)、引用透明性(不同的状态下相同的输入总是有一致的输出)、天生具有表达并发和递归语义的能力。

以表达递归语义的能力为例，同样是写一个完整的计算器程序，Ocaml程序的代码量在30行以内而基于Java类的设计完整实现需要几百行代码，这点用Ocaml修改扩展抽象语法树时更是深有体会，同样一个抽象语法树Java写起来会很多很杂Ocaml却很轻松。这让我认识到

> Java语言作为市场上目前最流行的语言一定是有它的原因，而不要因为别人吐槽Java复杂，类库框架太多代码量大而不去学习它。相反我们更应该看到的是，Java框架之多应用之广是一定有其背后的深层原因,我们要做的是究其本源，研究它的实用特性。为什么Python近几年十分火爆，因为Python学起来简单使用方便，适合快速搭建原型。

> 认识到语言提供的实用特性，充分挖掘语言的表达能力，再应用于合适的场景中，研究这些比任何的语言纷争要显得更有意义。这就是我觉得为什么要深入理解C++对象模型、内存管理方面的知识(即使你用Java做开发)，同样也是至少要学习一门函数式语言的原因。


# 参考

* [如何理解智能指针](https://www.zhihu.com/question/20368881)
* [理解C++的一些基础概念](http://blog.csdn.net/jnu_simba/article/details/9323739)
* [值语义](http://www.cnblogs.com/Solstice/archive/2011/08/16/2141515.html)
* [值语义和引用语义](http://www.cnblogs.com/my_life/articles/3986243.html)
* [循环引用](http://blog.csdn.net/xtzmm1215/article/details/45868835)
* [weak_ptr](http://stackoverflow.com/tags/weak-ptr/hot)
* [Smart Pointers - What, Why, Which?](http://ootips.org/yonat/4dev/smart-pointers.html)
* [Why doesn't C++ have a garbage collector?](http://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector?lq=1)
* [passing references to std::shared_ptr or boost::shared_ptr](http://stackoverflow.com/questions/327573/c-passing-references-to-stdshared-ptr-or-boostshared-ptr?rq=1)